diff --git a/Makefile b/Makefile
index f490f2f..3f4b058 100644
--- a/Makefile
+++ b/Makefile
@@ -35,7 +35,7 @@ RUSTC ?= rustc
 RUST_TARGET ?= x86_64-unknown-none
 RUST_USER_LIB ?= rust/libuserlib.a
 RUST_USER_RLIB ?= rust/libuserlib.rlib
-RUST_USER_PROGS = hello
+RUST_USER_PROGS = hello netd
 RUST_USER_OBJS := $(addsuffix .o,$(RUST_USER_PROGS))
 
 CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -fno-omit-frame-pointer
diff --git a/defs.h b/defs.h
index 258bf9f..ad630a5 100644
--- a/defs.h
+++ b/defs.h
@@ -190,4 +190,5 @@ void            clearpteu(pml4e_t *pgdir, char *uva);
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
 
 // rust/net.rs
-void            net_init(void);
\ No newline at end of file
+void            net_init(void);
+int             net_get_mac(uchar*, int);
\ No newline at end of file
diff --git a/rust/kernel/net.rs b/rust/kernel/net.rs
index 37dcc72..1a199ab 100644
--- a/rust/kernel/net.rs
+++ b/rust/kernel/net.rs
@@ -35,26 +35,41 @@ unsafe fn outl(port: u16, data: u32) {
 
 const KERNBASE: u64        = 0xFFFF8000_00000000;
 
-const REG_EERD: usize       = 0x00014;
-const REG_RXDESCLO: usize   = 0x02800;
-const REG_RXDESCHI: usize   = 0x02804;
-const REG_RXDESCLEN: usize  = 0x02808;
-const REG_RXDESCHEAD: usize = 0x02810;
-const REG_RXDESCTAIL: usize = 0x02818;
-const REG_RXDCTL: usize     = 0x02828;
-
-const EERD_START: u32       = 1 << 0;
-const EERD_DONE: u32        = 1 << 4;
-const EERD_ADDR_SHIFT: u32  = 1 << 3;
-const EERD_DATA_SHIFT: u32  = 1 << 4;
+const REG_EERD: usize        = 0x00014;
+const REG_TCTL: usize        = 0x00400;
+const REG_TIPG: usize        = 0x00410;
+const REG_RXDESCLO: usize    = 0x02800;
+const REG_RXDESCHI: usize    = 0x02804;
+const REG_RXDESCLEN: usize   = 0x02808;
+const REG_RXDESCHEAD: usize  = 0x02810;
+const REG_RXDESCTAIL: usize  = 0x02818;
+const REG_RXDCTL: usize      = 0x02828;
+const REG_TXDESCLO: usize    = 0x03800;
+const REG_TXDESCHI: usize    = 0x03804;
+const REG_TXDESCLEN: usize   = 0x03808;
+const REG_TXDESCHEAD: usize  = 0x03810;
+const REG_TXDESCTAIL: usize  = 0x03818;
+
+const EERD_START: u32        = 1 << 0;
+const EERD_DONE: u32         = 1 << 4;
+const EERD_ADDR_SHIFT: u32   = 1 << 3;
+const EERD_DATA_SHIFT: u32   = 1 << 4;
 
 const RXDCTL_PTHRESH_SHIFT: u32 = 0;
 const RXDCTL_HTHRESH_SHIFT: u32 = 8;
 const RXDCTL_WTHRESH_SHIFT: u32 = 16;
 const RXDCTL_ENABLE: u32        = 1 << 25;
 
+const TCTL_EN: u32          = 1 << 1;
+const TCTL_PSP: u32         = 1 << 3;
+const TCTL_CT_SHIFT: u32    = 4;
+const TCTL_COLD_SHIFT: u32  = 12;
+const TIPG_DEFAULT: u32     = 0x0060_200A;
+
 const NET_RX_DESC_COUNT: usize = 32;
+const NET_TX_DESC_COUNT: usize = 32;
 const PGSIZE: usize = 4096;
+const TX_STATUS_DD: u8 = 1 << 0;
 
 struct NetState {
     mmio: *mut u8,
@@ -65,6 +80,9 @@ struct NetState {
     rx_descs: *mut RxDesc,
     rx_buffers: [*mut u8; NET_RX_DESC_COUNT],
     rx_cur: u32,
+    tx_descs: *mut TxDesc,
+    tx_buffers: [*mut u8; NET_TX_DESC_COUNT],
+    tx_tail: u32,
 }
 
 struct NetStateCell(UnsafeCell<NetState>);
@@ -90,6 +108,9 @@ static STATE: NetStateCell = NetStateCell::new(NetState {
     rx_descs: ptr::null_mut(),
     rx_buffers: [ptr::null_mut(); NET_RX_DESC_COUNT],
     rx_cur: 0,
+    tx_descs: ptr::null_mut(),
+    tx_buffers: [ptr::null_mut(); NET_TX_DESC_COUNT],
+    tx_tail: 0,
 });
 
 #[repr(C)]
@@ -102,6 +123,17 @@ struct RxDesc {
     special: u16,
 }
 
+#[repr(C)]
+struct TxDesc {
+    addr: u64,
+    length: u16,
+    cso: u8,
+    cmd: u8,
+    status: u8,
+    css: u8,
+    special: u16,
+}
+
 fn v2p(addr: *mut u8) -> u64 {
     (addr as u64).wrapping_sub(KERNBASE)
 }
@@ -277,6 +309,55 @@ fn rx_init(state: &mut NetState) {
     }
 }
 
+fn tx_init(state: &mut NetState) {
+    unsafe {
+        let desc_mem = kalloc();
+        if desc_mem.is_null() {
+            cpanic(b"net: cannot allocate tx descriptors\0");
+        }
+        ptr::write_bytes(desc_mem, 0, NET_TX_DESC_COUNT * size_of::<TxDesc>());
+
+        state.tx_descs = desc_mem as *mut TxDesc;
+        state.tx_tail = 0;
+
+        for i in 0..NET_TX_DESC_COUNT {
+            let buf = kalloc();
+            if buf.is_null() {
+                cpanic(b"net: cannot allocate tx buffer\0");
+            }
+            ptr::write_bytes(buf, 0, PGSIZE);
+            state.tx_buffers[i] = buf;
+
+            let desc = state.tx_descs.add(i);
+            (*desc).addr = v2p(buf);
+            (*desc).length = 0;
+            (*desc).cso = 0;
+            (*desc).cmd = 0;
+            (*desc).status = TX_STATUS_DD;
+            (*desc).css = 0;
+            (*desc).special = 0;
+        }
+
+        let tx_phys = v2p(state.tx_descs as *mut u8);
+        writereg(state, REG_TXDESCLO, tx_phys as u32);
+        writereg(state, REG_TXDESCHI, (tx_phys >> 32) as u32);
+        writereg(
+            state,
+            REG_TXDESCLEN,
+            (NET_TX_DESC_COUNT * size_of::<TxDesc>()) as u32,
+        );
+        writereg(state, REG_TXDESCHEAD, 0);
+        writereg(state, REG_TXDESCTAIL, 0);
+
+        let tctl = TCTL_EN
+            | TCTL_PSP
+            | (0x10 << TCTL_CT_SHIFT)
+            | (0x40 << TCTL_COLD_SHIFT);
+        writereg(state, REG_TCTL, tctl);
+        writereg(state, REG_TIPG, TIPG_DEFAULT);
+    }
+}
+
 fn setup_mmio(state: &mut NetState, bus: u8, slot: u8, func: u8) {
     let bar0 = pci_config_read_u32(bus, slot, func, 0x10);
     if (bar0 & 0x1) != 0 {
@@ -327,9 +408,23 @@ fn net_init_internal() {
     print_mac_address(state);
     print(b"Initializing RX ring...\n\0");
     rx_init(state);
+    print(b"Initializing TX ring...\n\0");
+    tx_init(state);
 }
 
 #[no_mangle]
 pub extern "C" fn net_init() {
     net_init_internal();
+}
+
+#[no_mangle]
+pub extern "C" fn net_get_mac(dst: *mut u8, len: usize) -> i32 {
+    if dst.is_null() || len < 6 {
+        return -1;
+    }
+    unsafe {
+        let state = STATE.get();
+        ptr::copy_nonoverlapping(state.mac.as_ptr(), dst, 6);
+    }
+    0
 }
\ No newline at end of file
diff --git a/rust/libuserlib.rlib b/rust/libuserlib.rlib
index 0aaae24..dc228ad 100644
Binary files a/rust/libuserlib.rlib and b/rust/libuserlib.rlib differ
diff --git a/rust/userlib.rs b/rust/userlib.rs
index 876f265..5f09eef 100644
--- a/rust/userlib.rs
+++ b/rust/userlib.rs
@@ -24,6 +24,7 @@ const SYS_UNLINK: u64 = 18;
 const SYS_LINK: u64 = 19;
 const SYS_MKDIR: u64 = 20;
 const SYS_CLOSE: u64 = 21;
+const SYS_GETMAC: u64 = 22;
 
 // File modes
 pub const O_RDONLY: i32 = 0x000;
@@ -145,6 +146,13 @@ pub fn uptime() -> i32 {
     unsafe { syscall(SYS_UPTIME, 0, 0, 0) as i32 }
 }
 
+pub fn getmac(buf: &mut [u8]) -> i32 {
+    if buf.len() < 6 {
+        return -1;
+    }
+    unsafe { syscall(SYS_GETMAC, buf.as_mut_ptr() as u64, buf.len() as u64, 0) as i32 }
+}
+
 pub fn print(s: &str) {
     write(1, s.as_bytes());
 }
diff --git a/rust/userprogs/netd.rs b/rust/userprogs/netd.rs
new file mode 100644
index 0000000..1724135
--- /dev/null
+++ b/rust/userprogs/netd.rs
@@ -0,0 +1,42 @@
+#![no_std]
+#![no_main]
+
+extern crate userlib;
+
+use userlib::{exit, getmac, println, write};
+
+#[no_mangle]
+pub extern "C" fn main() -> i32 {
+    let mut mac = [0u8; 6];
+
+    if getmac(&mut mac) < 0 {
+        println!("netd: failed to read mac address");
+        exit(1);
+    }
+
+    println!("netd: mac address");
+    print_mac(&mac);
+    exit(0)
+}
+
+fn print_mac(mac: &[u8; 6]) {
+    const HEX: &[u8; 16] = b"0123456789abcdef";
+    let mut buf = [0u8; 18];
+    let mut idx = 0;
+
+    for (i, byte) in mac.iter().enumerate() {
+        buf[idx] = HEX[(byte >> 4) as usize];
+        idx += 1;
+        buf[idx] = HEX[(byte & 0x0F) as usize];
+        idx += 1;
+        if i != mac.len() - 1 {
+            buf[idx] = b':';
+            idx += 1;
+        }
+    }
+
+    buf[idx] = b'\n';
+    idx += 1;
+
+    let _ = write(1, &buf[..idx]);
+}
diff --git a/syscall.c b/syscall.c
index af493cf..1ab4d85 100644
--- a/syscall.c
+++ b/syscall.c
@@ -122,6 +122,7 @@ extern addr_t sys_unlink(void);
 extern addr_t sys_wait(void);
 extern addr_t sys_write(void);
 extern addr_t sys_uptime(void);
+extern addr_t sys_getmac(void);
 
 // PAGEBREAK!
 static addr_t (*syscalls[])(void) = {
@@ -146,6 +147,7 @@ static addr_t (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_getmac]  sys_getmac,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..524ee4e 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_getmac 22
diff --git a/sysproc.c b/sysproc.c
index 3b18408..ddcade0 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -87,3 +87,23 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+addr_t
+sys_getmac(void)
+{
+  addr_t uptr;
+  int len;
+  uchar mac[6];
+
+  if(argaddr(0, &uptr) < 0)
+    return -1;
+  if(argint(1, &len) < 0)
+    return -1;
+  if(len < sizeof(mac))
+    return -1;
+  if(net_get_mac(mac, sizeof(mac)) < 0)
+    return -1;
+  if(copyout(proc->pgdir, uptr, mac, sizeof(mac)) < 0)
+    return -1;
+  return 0;
+}
